---
title: 网络流做题记录
math: true
date: 2023-07-22 23:37:28
categories: [算法竞赛]
tags: [图论, 网络流, 题单/题解]
summary: 记录一些经典的网络流模型，做过的网络流题面（包括耳熟能详的网络流 24 题）
cover:
---

### CF510 E

[Fox And Dinner](https://codeforces.com/problemset/problem/510/E)

### 2022 江苏省赛 B

[Prime Ring Plus](https://codeforces.com/gym/103743/problem/B)

### 2023 杭电多校 2 1012

[Coin](https://acm.hdu.edu.cn/showproblem.php?pid=7298)

**题目大意**

$n$ 个人初始时每人手里的一个硬币，每个人手中的硬币数量不能超过$a_i$个，进行 $m$ 轮操作，每轮给出 $A, B$，可以选择 $A$ 给 $B$ 一个硬币，或者 $B$ 给 $A$ 一个硬币，或者什么都不做，$n$ 个人中有 $k$ 个人是我的朋友，每轮操作都由我控制，希望让我所有的朋友能够拿到的硬币和最大，求出最大值。

**题解**

给定初始条件（源点与每个点的容量），$A \rightarrow B$ 存在一条权为 $1$ 的边（带容量限制的有向边），点存在容量限制（网络流经典拆点），求和的最大值（汇点与最大流）。通过以上这些特征基本上可以确定此题是一道最大流。

由于 $m$ 个操作存在时间上的先后顺序，我们可以考虑对每个点拆成 $m$ 个点（代表该点每个时间上的状态），这 $m$ 个点串联（单向边，并且所有边容量为 $a_i$），对于每个时间上的操作，我们将 $A, B$ 在对于的时间状态上连一条容量为 $1$ 的双向边，最后将所有点的最后时间状态连接到汇点（边权容量为$a_i$）。

当然，发现此时创建的点的数量太多了，并且很多点都是冗余的，因此可以在需要用到该点的时间状态时再创建。最终得到的点的个数为 $m$ , 边的数量为 $n + m + k$。

参考代码：
```cpp
#include <bits/stdc++.h>

using namespace std;
using ll = long long;
typedef pair<int, int> PII;
const int MAX_N = 2e5 + 10, INF = 1e9 + 7, mod = 998244353;

namespace Dinic {
    using ll = long long;
    const int MAX_V = 2e4 + 10;
    struct Edge {
        int from, to;
        ll  cup, flow;
        Edge(int u, int v, ll c, ll f) : from(u), to(v), cup(c), flow(f) {}
    };
    struct Graph {

        int s, t, n, m;
        vector<Edge> es;
        vector<int> G[MAX_V];
        int level[MAX_V], iter[MAX_V];
        bool vis[MAX_V];

        Graph(int s, int t, int n = MAX_V) : n(n), s(s), t(t) {
            es.clear();
            for(int i = 0; i < n; i ++) {
                G[i].clear();
            }
        };

        void addEdge(int u, int v, ll c) {
            es.push_back({u, v, c, 0}), es.push_back({v, u, 0, 0});
            m = es.size();
            G[u].push_back(m - 2), G[v].push_back(m - 1);
        }

        ll dfs(int v, ll f) {
            if(v == t || f == 0) return f;
            ll flow = 0, d;
            for(int &i = iter[v]; i < G[v].size(); i ++) {
                auto &e = es[G[v][i]], &reve = es[G[v][i] ^ 1];
                if(level[v] + 1 == level[e.to] && (d = dfs(e.to, min(f, e.cup - e.flow))) > 0) {
                    e.flow += d, reve.flow -= d;
                    flow += d;
                    f -= d;
                    if(! f) break;
                }
            }
            return flow;
        }

        bool bfs() {
            memset(vis, false, sizeof vis);
            queue<int> q;
            q.push(s);
            level[s] = 0;
            vis[s] = true;
            while(q.size()) {
                int v = q.front();
                q.pop();
                for(int i = 0; i < G[v].size(); i ++) {
                    auto &e = es[G[v][i]], &reve = es[G[v][i] ^ 1];
                    if(!vis[e.to] && e.cup > e.flow) {
                        vis[e.to] = true;
                        level[e.to] = level[v] + 1;
                        q.push(e.to);
                    }
                }
            }
            return vis[t];
        }

        ll maxflow() {
            ll flow = 0;
            while(bfs()) {
                memset(iter, 0, sizeof iter);
                flow += dfs(s, INF);
            }
            return flow;
        }

    };
};
using namespace Dinic;

void solve() {
    int n, m, k;
    cin >> n >> m >> k;
    int s = 0, t = 2e4 + 1;
    Graph gra(s, t);
    vector<int> a(n + 1);
    vector<int> cur(n + 1);
    for(int i = 1; i <= n; i ++) {
        cin >> a[i];
        gra.addEdge(s, i, 1);
        cur[i] = i;
    }
    int id = n + 1;
    for(int i = 1; i <= m; i ++) {
        int x, y;
        cin >> x >> y;
        int n1 = cur[x], n2 = cur[y];
        gra.addEdge(n1, n2, 1);
        gra.addEdge(n2, n1, 1);
        gra.addEdge(n1, cur[x] = id ++, a[x]);
        gra.addEdge(n2, cur[y] = id ++, a[y]);
    }
    for(int i = 0; i < k; i ++) {
        int x;
        cin >> x;
        int mp = cur[x];
        gra.addEdge(mp, t, a[x]);
    }
    cout << gra.maxflow() << '\n';
}

int main () {
    ios::sync_with_stdio(0);
    cin.tie(0);
    int _ = 1;
    cin >> _;
    while(_ --) {
        solve();
    }
}
```

其中在做这道题的时候，有一个假的做法也是值得做一些思考的，如果所有的每轮所能做的操作在时间上没有先后顺序，那么只需要设置出两个点，这两个点中连一条容量为 $m$ 的有向边作为操作总数的瓶颈，每次操作都需要经过这两个点。